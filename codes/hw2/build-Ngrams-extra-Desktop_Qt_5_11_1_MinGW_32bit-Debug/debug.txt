In the course of working on any programming project you will invariably run into a spot where your code just plain doesn’t work the way you want it to. It might not compile and give you some super cryptic error message. It might run but give the wrong answer, or run but never complete. Or it might run and crash for mysterious reasons. When this happens, you’ll need to debug your error before you can move on. As you may know, we have LaIR hours every Sunday through Wednesday from 7-11PM on the ground floor of the Tresidder Student Union. If you ever get really, really stuck, we recommend stopping on by to get some help. Learning how to debug effectively is one of the single most important skills you can have as a programmer. When you’re working outside the classroom - whether it’s in a research lab, an independent project, a company, a nonprofit, etc. - you won’t necessarily have the luxury of the LaIR to help you get unstuck, and yet you’ll still be expected to deliver results. Accordingly, if you ask for help in the LaIR, the section leaders are likely to inquire into more depth about how you’ve tried to fix the error on your own. If you haven’t made much of an effort to do so, the SLs are more likely to help show you how to debug your code than they are to find and fix the bug for you. Before you go to the LaIR to get help, you must go through the following checklist - in fact, the sign-up for LaIR will require you to answer the questions described below. In doing so, there’s an extremely good chance that you’ll figure out what the underlying error is and how to fix it. In the event that you aren’t able to sort out the issue, then you’ll have a much more targeted and focused question to bring to the LaIR. When you’re writing a program and you find that it doesn’t work, your instinct might be to try to take the code you have and change it to fix it. In some cases, this is totally fine. Maybe you look at the code and think “oh, whoops, I forgot a semicolon” or “oh whoops, I forgot a return statement.” That’s all fine and well. But if you’re in a spot where the code doesn’t work and you really legitimately don’t know what’s going on, one of the worst things you can do is to start making changes to your code without a plan. Now you have two bugs - the bug you originally had, plus the new one you just inserted by changing things. Now, imagine you’re running this function and you find that it gives back the wrong answer on the input “Banana,” and this shows up because the starter code compares your answer to a reference answer and says that it has the wrong answer. You can be fairly confident that the issue is that the distinctCharactersIn function is returning the wrong value, but until you know why it’s returning the wrong value it’s going to be hard to do anything about it. For example, here are four different things that could go wrong here: An important thing to keep in mind when debugging is that the bug can’t move. It’s sitting there in your code, hiding in plain sight, waiting to do the wrong thing. If you don’t make changes to your code, then it can’t move anywhere. It can’t sneak from one part of the code into the other. It’s just waiting to be found. It might seem silly to ask this, but it’s important to make sure that you understand what specifi-cally the issue is that you’re running into. If you show up in the LaIR and all you can say is “my program doesn’t work,” it’s unlikely that anyone is going to be able to help you fix the issue, since that information by itself isn’t precise enough for the section leaders to know what’s going on. As a first step, try to classify the error you’re getting into one of four different categories: What is the specific error message you’re getting? Is it localized to a particular line of code? If so, what line of code is that? If you have multiple different compiler errors in the same program, always just look at the first of them, since follow-up errors often result from the compiler trying to recover from an earlier error and failing. If you have a Qt Creator issue, you should also make sure to check out our Qt Creator Troubleshooting Guide. On what specific line is the program crashing? What sort of error are you getting back? Can you get a stack trace? Make sure you can answer all of these questions, since they’ll be important for smoking out the bug later on. In most cases, you can figure out where the crash occurs by running the program in debug mode and waiting for the debugger to pop up when something goes wrong. Once you’ve found the crash, you’ll need to localize it; see the “Localizing a Bug” section later on. Where in the program is the infinite loop? Don’t guess - use the debugger to find out. Run the program in debug mode, and when it seems to be hanging, click the “interrupt” button (it looks like a giant pause button) to pause the program at its current point. That should give you a stack trace of where you are in the program, which will pinpoint the specific area where the infinite loop occurs. You might find, sometimes, that your program isn’t in a loop but is just paused and waiting for you to type something in, in which case, problem solved! If you’re getting the wrong answer, what specific function is producing the wrong answer? Once you’ve found that function, there are a couple reasons why it could be giving a wrong answer. It might, for example, give back the wrong answer because the input that was provided to it was incorrect and the error is actually earlier on in the pro-gram. Therefore, your task at this point is to localize where the bug is (see the “Localizing the Bug” section). A unifying theme in the above discussion is that, when possible, you’ll want to use your tools to help you figure out what’s going wrong. When you first have a program that isn’t working, it can seem really overwhelming, but by asking the right questions you can convert the Hairy Scary problem of “it’s broken” into a more concrete question, like “what exactly is it about this particular loop that makes it run forever?” or “why does this particular line of code cause a crash?” Localizing a Bug In some cases, you’ll end up finding that your program does the wrong thing at a particular step - maybe it reads off the end of a string (oops), or perhaps it computes and returns the wrong value (oops). When that happens, you’ll have to identify the root cause of the problem before you can move on so that you know where to focus your efforts. As an example, let’s suppose that you want to write a function that takes in a string and counts up how many distinct characters it has. For example, “hi” has two distinct characters, while “hello” has four. One way you can do this is to sort the characters in the string alphabetically, then count up how many different “runs” of equal characters there are. For example, given the string “Banana,” you’d form the string “aaaBnn,” which has three runs of equal characters (aaa, B, nn) and therefore has three different characters. You could imagine writing the function like this: Without digging into your code a bit more, it’s hard to know for sure which of these errors is the real one. Therefore, when you find this bug, the first step is to localize it to a particular region of the code. Here are some things you may want to do: In what cases does this error occur? In coming up with an answer to this question, you’ll narrow down the scope of the cause of the problem so that you can get a sense of what to look for. Let’s go back to our “Banana” mishap from before. A great next step in that case would be to try running the program on inputs other than “Banana” so that you can try to sort out what’s going wrong. It wouldn’t be a bad idea to try running the program on a bunch of other strings (no pun intended) so that you can peel back the veil of mystery (pun intended) about what’s going on. If you have no idea what the issue might be, try running some different inputs through the pro-gram. Try small inputs: 0, the empty string, etc. Try large inputs. If you’re working with strings, try lower-case strings, UPPER-CASE STRINGS, and Mixed-CaSE strings. See what you find. Does the program work correctly on some cases? Write those cases down. Does the program fail on some other cases? Write those down too. If you’re working on a program and the only way you know how to trigger the error is on a very large input (say, a large sample file), then it’s doubly important to find another case where the error occurs. Chances are the issue has less to do with the fact that the input is big and more to do with the fact that the input contains some pattern somewhere that you don’t handle properly. One technique for figuring out the issue is to take the test file you’re getting the wrong answer on and to dramatically shrink it. Cut out the first half, or last half, and see if you still get an error. If so, cut that half in half, etc. Eventually, you’ll zero in on the issue. If that doesn’t work, look at the smaller test cases that you are passing. Is there anything that they all have in common? If so, try creating your own test cases that look different from those ones. Working with text files, and all the inputs are free of spelling errors? Mash the keyboard and generate some garbage. Working with numbers? Try odd numbers, even numbers, negative numbers, 0, fractions, etc. Just throw things at the program until you can reproduce it. If you can’t get the error to show up in other cases, or if you can only get the error to show up in super large files, that in itself might be worth a trip to the LaIR so that you can get the section leaders, who all have their share of Debugging Battle Scars, to offer some input. If you do have a better sense of what sorts of inputs cause the error and which sort don’t, look over them and see if there’s a pattern. In many cases there will be something obvious - you get the answer wrong for any strings of length two or more, or the function crashes on anything of odd length, or it fails on anything ending in the letter e, etc. - and that’s really, really good to know because it will inform what you should look for in the next step. Alternatively, if the program always gives the wrong answer, then that’s good to know as well - it means that there’s something fundamentally amiss and that you’re not looking for edge cases.